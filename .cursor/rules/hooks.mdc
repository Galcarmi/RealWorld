---
description: 
globs: 
alwaysApply: true
---
# Custom Hook Rules

## Hook Structure Pattern
Follow this consistent pattern for all custom hooks:

```typescript
type NavigationProps = NavigationProp<RootStackParamList>;

const useFeatureName = () => {
  // 1. Store/state consumption
  const { isLoading, user, errors } = useStore();
  const navigation = useNavigation<NavigationProps>();

  // 2. Callback functions with useCallback
  const onAction = useCallback((value: string) => {
    store.performAction(value);
  }, []);

  const onAsyncAction = useCallback(async () => {
    Keyboard.dismiss();
    await store.performAsyncAction();
  }, []);

  const onNavigation = useCallback(() => {
    navigation.navigate('ScreenName');
  }, [navigation]);

  // 3. useEffect for side effects
  useEffect(() => {
    if (errors) {
      showErrorModals(errors);
    }
  }, [errors]);

  useEffect(() => () => store.clear(), []);

  // 4. Return object with consistent naming
  return {
    // State
    user,
    isLoading,
    // Actions
    onAction,
    onAsyncAction,
    onNavigation,
  };
};

export default useFeatureName;
```

## Rules

### File Naming
- Use camelCase starting with "use": `useAuth.ts`, `useArticles.ts`
- Co-locate with screens when screen-specific
- Place in `utils/hooks/` when reusable across screens

### Hook Structure
1. **Type definitions** - navigation types, prop types
2. **Store/state consumption** - extract needed data from stores
3. **Callback functions** - wrap in `useCallback` for performance
4. **Side effects** - `useEffect` for cleanup, error handling
5. **Return object** - organized by state and actions

### Naming Conventions
- Hook functions: camelCase with "use" prefix (`useAuth`, `useArticles`)
- Callback functions: start with "on" (`onLogin`, `onNavigateToSignUp`)
- State variables: descriptive names (`isLoading`, `user`, `errors`)

### Performance Optimization
- Always wrap callbacks in `useCallback`
- Include proper dependencies in dependency arrays
- Use `useMemo` for expensive computations

### Navigation Handling
- Type navigation properly: `NavigationProp<RootStackParamList>`
- Wrap navigation calls in `useCallback`
- Include navigation in dependency array

### Side Effects
- Dismiss keyboard before async operations: `Keyboard.dismiss()`
- Handle errors with `useEffect` and error display utilities
- Clean up stores in cleanup effect: `useEffect(() => () => store.clear(), [])`

### Return Pattern
- Group returned values logically (state first, then actions)
- Use consistent naming pattern with "on" prefix for actions
- Don't return store instances directly, only needed values

### Best Practices
- Keep hooks focused on single feature/screen
- Extract reusable logic into separate utility hooks
- Always type the hook's return value when complex
- Use custom hooks to keep components clean of business logic
